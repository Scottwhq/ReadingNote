# 代码大全读书笔记

##第一章 软件构建
    
    将通常我们认为的coding，programming看成construct，对于写代码，更重要的是明确软件/系统/web等等的构建过程
    
    软件构建过程：
    
    1.定义问题
    
    2.需求分析
    
    3.规划构建
    
    4.软件架构/高层设计
    
    5.详细设计
    
    6.编码与调试
    
    7.单元测试
    
    8.集成测试
    
    9.集成
    
    10.系统测试
    
    11.保障维护
    
    我个人的看法是1,2是确定需求的过程，确定下来我们需要做些啥，在问题明确的基础上进行3,4,5即架构设计部分，
    这部分最为消耗脑细胞，既要具有一些前瞻性，也不能过于将系统变得复杂，而6就是我们正常而言的coding阶段，
    7~10是测试阶段，为了确保代码不要太惨，在接受大众摧残前要保证不会有明显的bug，最后的保障维护就是在系统
    上线后能对其发生的问题进行维护
    
    构建活动是软件开发中的核心活动，开发的主要时间是用于构建活动，可以提高开发效率，源代码是对构建活动的唯一精确描述，是构建活动的产物

## 第二章 隐喻对软件开发的指导

    隐喻与算法
    
    隐喻：将软件开发的过程与传统行业或者活动进行对比，通过传统活动的一些好的方法来指导代码构建，常见的有将软件开发比作写作，培育，建造。
    
    算法：可预测的，确定性的，不易变化的

## 第三章 前期准备的重要性

    1.前期准备是十分重要的，一般而言，构建活动占整个过程的65%
    
    2.测试是质量保证的后续环节，真正对系统的质量保证是前期准备中的高质量设计
    
    3.实现一个系统前，一定要理解这个系统是做什么的，它该如何做到这些
    
    4.程序员是食物链的底层，架构师吃掉需求，设计师吃到架构，程序员消化设计
    
    5.3-1有一张表，各阶段解决问题的平均时间
    
    6.迭代技术往往能够减少“前期准备”不足，但不能完全解决
    
    7.序列式开发法和迭代式开发法
    
    需求稳定；设计直截了当，而且理解透彻；开发团队对于这一应用领域非常熟悉；项目的风险很小；"长期可预测性”很重要；后期改变需求，设计，编码的代价比较大 适合序列式开发法
    
    需求并没有被理解透彻，不稳定；设计很复杂，或者有挑战性，或者两者兼具；开发团队对于这一应用领域不熟悉；项目包含许多风险；“长期可预测性”不重要；后期改变需求，设计和编码的代价比较小 适合迭代式开发
    
    8.问题定义只定义问题是什么，问题定义应该用客户的语言来书写，而且应该从客户的角度来描述问题；未能定义问题可能会导致用大量的时间去解决错误的问题。同时你并没有解决问题。
    
    9.明确的需求很重要，明确的需求很重要，明确的需求很重要，你懂的，PM最好理解这点
    
    10.稳定的需求是开发的圣杯
    
    11.平均水平，需求会有25%的变化
    
    12.计划严格依照需求行事，实际上就是计划不对客户的要求做出回应
    
    13.构建期间处理需求变更
    
    1）利用书中的需求核对表来评估需求的质量 p42
    
    2）确保每一个人都知道需求变更的代价
    
    3）建立一套变更控制程序
    
    4）使用能适应变更的开发方法
    
    5）放弃这个项目
    
    6）注意项目的商业案例
    
    14.离开了良好的软件架构，你可能瞄准了正确的问题，却用了错误的方法，依然不会成功。
    
    15.架构需要注意的典型组成部分：
    
    1）程序组织
    
    2）主要的类；详细定义主要的类的功能
    
    3）数据设计；所用的数据库，数据表的设计
    
    4）业务规则；如果架构依赖于特定的规则，那么就应该详细描述这些规则
    
    5）用户页面设计：用户界面常常在需求阶段进行详细说明
    
    6）资源管理：架构应该描述一份管理稀缺资源的计划（数据库连接，线程，句柄等）
    
    7）安全性：架构应该描述实现设计层和代码层面的安全性的方法
    
    8）性能：性能目标可以包括资源的使用，这时，性能目标也应该详细定义资源之间的优先顺序
    
    9）可伸缩性：可伸缩性是指系统增长以满足未来需求的能力。
    
    10）互用性：与其他软件，硬件交互
    
    11）国际化/本地化：语言，编码等
    
    12）输入输出流一定要注意
    
    13）错误处理：是计算机科学中最棘手的问题之一
    
    14）容错性
    
    15）满足各类功能的架构可行性（我能否肝出来）
    
    16）过渡工程：系统在检测到错误后继续运行的能力
    
    17）对于上述系统，我们是造好，还是外包买好
    
    具体check checklist表
    
    14.一个运行良好的架构花费在问题定义，需求分析，软件架构上的时间，依据项目的需要而变化，一般在10%~30%左右


## 第四章 关键的构建决策

    1.选择适合的语言：我个人熟悉的语言C，C++，Java，PHP，略有了解的语言python，JavaScript，SQL，VB，C#，MATLAB，HTML，希望学习的语言Ruby，lua，Object C，scala，Haskell等，感觉学不完啊
    
    2.编程约定：树立自己的编码风格
    
    3.技术浪潮中自己的位置：技术变革中找准方向
    
    4.深入一种语言去编程：C++各类书籍，TIPI撸起
    
    5.选择主要的构建实践方法：p69，70两张很nice的checklist

## 第五章 软件构建中的设计

### 设计中的挑战

    软件设计意味着去构思，创造或发明一套方案方案，把一份计算机软件的规格说明书要求转变为实际运行的软件
    
    1.设计是一个“险恶”的问题——简单的讲这里的险恶多指挥不停地改变，你必须先解决一遍后再能更加明确地定义问题，从来迭代式地逼近真正要解决的问题，做出真正可以解决问题的设计（这是我个人的理解）
    
    2.软件设计的结果应该是1.组织良好 2.干净利落的，然而形成设计的过程是了无章法的。（设计的过程不像是解题，可以依据一定的公理方法来推出最后的结果，所以过程是充满错误的，而设计阶段发现错误并改正远比到了编码阶段时要的代价小）
    
    3.设计就是确定取舍和调整顺序的过程。（在算法竞赛中，时间复杂度往往直观重要，而在实际生产中，也许数据的量非常小，这个时候代码的可读性以及编写效率等成了较重的权重，取舍很重要）
    
    4.设计受到诸多限制（设计的要点，创造可能发生的事情，阻止可能发生的事情，后面的例子中也会有，比如子系统之间的通信，不能毫无限制可言）
    
    5.设计是不确定的，一个启发式的过程，是自然而然形成的，它是再不断的设计评估，非正式讨论，写试验代码以及修改试验代码中演化和完善的。
    
### 关键的设计概念
    
    1.全书最重要的观点目前来看没有之一：软件的首要技术使命——管理复杂度
    
    2.软件随着不停地迭代，加入新的功能，需要解决更大的难题，其交互行为越来越复杂，这些转而又增加了软件解决方案本质性困难，当项目因技术性原因而导致失败时，往往是因为失控的复杂度。
    
    3.当没有人知道对一处代码的改动会对其他代码造成什么影响的时候，项目也快停止进站了。
    
    4.陷入复杂度沼泽的现象——自己顽固地使用一种明显毫无作用的方法（我的理解是谁都知道这方法很蠢，但我们依然没有办法，系统过于复杂，我们除了用这种方法别无方法）。
    
    5.软件架构层次上，可以将系统划分为子系统以降低问题的复杂度，子系统之间互相依赖越少，越容易专注在问题的一部分（低耦合）
    
    6.高代价，低效率的设计的三种根源：用复杂的方法解决简单的问题；用简单但错误的方法解决复杂的问题；用不恰当的复杂的方法解决复杂的问题
    
    7.管理复杂度的方法：1.把任何人在同一时间需要处理的本质复杂度的量减到最少；2.不要让偶然性的复杂度无谓地快速增长
    
    8.理想设计的特征：最小的复杂度；易于维护；松散耦合；可拓展性；可重用性；高扇入（大量的类使用某个基础类）；低扇出（一个类里少量使用其他的类）；可移植性；精简性（不要有大量冗余代码）；层次性；标准技术（尽量使用标准，常用的技术）
    
    9.设计的层次：软件系统——>分解为子系统或包——>分解为类——>分解成子程序（routines）——>子程序的内部设计
    
### 设计构造块：启发式方法

    1.找出现实世界的对象
    
    2.形成一致的抽象（基类，用简化的观念来考虑复杂的概念）
    
    3.封装实现细节（不让别人看到复杂的内部逻辑细节，你能看到的就是你能得到的）
    
    4.当继承能简化设计时就继承（继承很危险，第六章有讲）
    
    5.信息隐藏（黑盒子，而不是玻璃盒，类的接口应该尽量少地暴露其内部工作机制。类很像冰山，只有1/8暴露在表面）信息隐藏所保管的秘密主要有两大类（1.隐藏复杂度，其他人不用关注，2.变化源，变化发生时，变化只在内部进行，其他人看来不会有影响）这点非常非常重要，做设计时好好问自己，要隐藏些什么。
    
    6.设计时好好分析哪里会发生变化或者变化的频率高于其他地方，将其找出来并隔离
    
    7.高内聚低耦合（老生常谈）
    
    8.使用一些常用的设计模式来解决问题（设计模式就是经过考验的前人的设计总结，轮子，最重要的在于降低风险以及便于其他人理解）这一块要单独看些书
    
    9.设计启发的一个总结p108
    
### 设计实践

    主体还是分而治之以及自顶向上自底向上这些方法相结合，还是之前的话，设计时了无章法的，所以要试
    
## 第六章 可以工作的类

    类的基础——ADT抽象数据结构，使用ADT的好处：隐藏实现细节；改动不会影响到整个程序；让接口提供更多的信息；更容易提高性能；让程序的正确性更显而易见；程序更具自我说明性（更好读）；类相关于有继承和多态的ADT
    
    1.良好的类接口：好的抽象（便于别人理解类抽象的是什么）；良好的封装（尽可能限制类与成员的可访问性，不要公开暴露成员数据，多使用private，不要把私用的实现细节放入类接口中，不要对类的使用者做假设；避免使用友元类，让阅读代码比写方便，千万避免破坏封装性的行为）；
    
    2.包含和继承，7+-2规则
    
    1）通过包含来实现has a关系，万不得已时才使用private继承来实现有一个关系，警惕超过7个数据成员的类
    
    2）用public继承来实现是一个关系，使用继承一定要有详细的说明，不然就别用，对基类一定要做严格的check，确保只继承需要的部分，不要覆盖一个不可覆盖的成员函数，公共接口，数据，操作尽量放在继承树种较高处；类是抽象概念，别混成实例，同样基类如果只有一个派生类，别过早设计，继承树的高度不能太高，3层左右就很复杂了，尽量使用多态来替代case，数据尽量private，protected也不是很安全
    
    3.类里面的子程序越多越容易出错，所以7+-2，减少类调用的子程序数量，低扇出，对其他子程序的间接调用尽量减少，一般而言减少类之间的相互合作
    
    4.创建类的原因：对象建模；抽象概念；降低复杂度；隔离复杂度；隐藏实现细节；限制改变影响；隐藏全局数据；让参数传递更流畅；建立中心控制点；代码复用；便于重构
    
    5.避免的类：万能类；无关紧要的类；别用动词命名类；
    
    
## 第七章

    1.不良子程序的常见问题：
        1）子程序名很差（之前打算重构的促销活动部分的displayPromo_XX）
        2）没有文档
        3）布局代码风格不统一
        4）传入参数命名问题，命名为inputXXX的就不能被改变
        5）读写全局变量
        6）所做事情没有一个统一的目的，太过杂糅
        7）没有防错（实践中经常遇到）
        8）出现过多神秘数值（多用定义）
        9）出现无用参数（很多IDE可以帮检查）
        10）参数过多以及参数顺序混乱（haojing里很多遗留代码也有这种问题）
    
    2.创建子程序的原因
        1）降低复杂度（全书很多都是围绕这个观点）
        2）引入中间易懂抽象，方便阅读
        3）避免代码重复（最初的想法）
        4）隐藏顺序，指针操作（有些算法的操作顺序比较反人类，指针操作亦然）
        5）提高可移植性
        6）简化复杂的布尔判断（各种check）
        7）方便以后修改（不用改多处了，同3）
        
    
    3.子程序层面上设计的考虑在于需要较高的内聚性，但功能的内聚性是我们希望的
    
    4.取一个好的子程序名（英文太差了，词汇贫瘠啊）
        1）正确描述子程序要干的事情
        2）避免使用无意义，模糊，表述不清的词汇
        3）不要仅通过数字来形成不同的子程序名（之前重构促销活动犯了错）
        4）子程序名长度9~15为宜
        5）给函数名时要对返回值有所描述（以后注意，是object还是array）
        6）尽量使用语气强烈的动词加宾语的形式。 p172有很多动词对比词
        
    
    5.子程序长度（超过200行时就要小心点了）
    
    6.子程序参数的使用
        1）使用所有的参数
        2）有一定的顺序（输入在前，状态，出错变量在后等）
        3）对参数要有一定的说明
        4）尽量控制在7个以内
        5）一个有意思的问题，是传入整个object还是其中某几个参数，看需要的这几个参数的作用，从需要表达何种抽象来考虑问题，调用子程序前有set up代码，调用子程序后有take down方法都是不好的设计
        
    
    7.函数和过程的对比，有无返回值，某些过程式的函数可返回执行结果。检查所有可能的返回路径，这里经常有可能有各种奇葩错误，不要返回指向局部数据的引用或指针
    
    8.宏：首先能不用尽量不用，有太多可以替代它的东西，命名全大写，一定要注意用大括号大起来，常见的宏定义错误 #define MULT(a) a*a
    
    9.inline：内联函数，好处：提高效率，坏处：子程序会变长，违反封装原则）
